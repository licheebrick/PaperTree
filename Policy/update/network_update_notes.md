# Abstractions for Network Update

## Basic
* SIGCOMM 2012, 300+ citations
* Jennifer Rexford
* First Read: 11.30

## Best for reference:
* A summary of example changes to network configuration and the desired update properties; (Table 1)
* Mininet environment?
* Three typical topologies in datacenters: (fattree, smallworld), enterprises (fattree) and a random topology (waxman).
* http://www.frenetic-lang.org/

## Focus:
* Consistent network update:

## Aspects of Contribution:
* Introduce Notion: Consistent network update;
  - per-packet
  - per-flow
* Verification tools; (No details)
* implementation and experiments;

## Possible improvements
* Only maintains the 'trace properties' of the network;
  - CAN: Access control, connectivity, routing correctness, loopfreedom, correct VLAN tagging, and waypointing;
  - CANNOT: Timing properties and relations between multiple packets including quality of service, congestion control, in-order delivery, or flow affinity;

## Structure
### Introduction
* Prevent transient anomalities;
* The necessity of Foundational principles for designing solutions (protocol irrelevant);
* SDN feature, bugs exist when updates;
* Overall Introduction of their approach;

### Example
* A simple access control example to illustrate the challenges in network updates;
* Two example usage of this work:
  - per-packet-update(cfg2): select a suitable mechanism to implement the update;
  - verify(cfg2, topo, policy): verify if policy still holds for topo\&cfg2;

### Model
Similar to HSA.

* Two kinds of transitions: Process(forwarding) and Update(update policy).

### Per-packet Abstractions
* per-packet-update:
  - definition on a update sequence *us*;
  - a trace is either generated by original configuration C, or by configuration C' after apply *us*;
* ~-property preservation:
  - definition on a update sequence *us*;
  - preserves all properties that do not distinguish traces related by ~;

### Per-packet Mechanisms
* One-touch updates: there is no trace which contains two distinct elements that both appear in the domain of update functions;
  - Loop-free switch updates;
  - Ingress port updates;
* Unobservable updates: every trace generated by C1 is contained in the trace generated during the update from C1 to C2;
* Two-Phase Update:
  - First installing the new configuration on internal ports, but only enabling the new configuration for packets containing the correct version number.
  - Then updates the ingress ports one-by-one to stamp packets with the new version number.
* Optimized mechanisms: Simplify pure extensions and retractions;

### Checking Property Invariance
* Model: Computation Tree Logic (CTL)
* Deploy: Details are hidden;
  - On small examples-with tens of switches and hundreds of rules—the NuSMV tool reports results in under a second.
  - Larger examples—such as guaranteeing no loops for shortest-path routing over Waxman graphs with hundreds of switches and hundreds of thousands of rules—take over an hour.

### Per-Flow Consistency
* Example: a server load-balancer needs all packets from the same TCP connection to reach the same server replica.
* Mechanisms:
  - Switch rules with timeouts (Implemented);
  - Wildcard cloning;
  - End-host feedback;

### IMPLEMENTATION AND EVALUATION
* Kinetic - implements the update abstractions introduced in this paper;
  - Python;
  - *per_packet_update* and *per_flow_update* functions;
  - Runs on top of OpenFlow 1.0;
* Experiments: (18 sets)
  - Mininet environment; ?
  - Two canonical network applications: Routing and multicast;
  - Topology of experiment network: network topologies found in datacenters (fattree, smallworld), enterprises (fattree) and a random topology (waxman).
  - Three scenarios: update hosts / routes / both;

### Related Works
* 2011, workshop paper, HotNets, “Consistent updates for software-defined networks: Change you can believe in!”;
* “Graceful network state migrations,” IEEE/ACM Trans. on Networking, vol. 19, Aug 2011.

Most are tied to distributed routing protocols, rather than the logically-centralized world of SDN.

* Model from HSA

### Future Work
* Faster and cheaper;
* Per-flow consistent update abstraction, and prove the correctness of the per-flow update mechanisms;
* Explore other notions of consistency that either perform better (but remain sufficiently strong to provide benefits beyond eventual consistency) or provide even richer guarantees.
